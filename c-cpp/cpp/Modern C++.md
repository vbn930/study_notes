Modern C++은 일반적으로 C++11 이후 버전들의 문법들을 의미한다.
## auto
auto 타입을 사용하면 컴파일 단계에서 컴파일러가 자체적으로 대입된 값의 타입을 바탕으로 타입을 추론해서 적절한 타입으로 교체해준다.
template 그리고 auto 같이 타입을 컴파일 단계에서 자동으로 추론 해주는 것을 type deduction 이라고 한다.
하지만, auto에는 복잡한 추론 규칙도 존재하고, 모든 타입을 암시적으로 추론해주지는 않는다.
### auto 사용 시 주의점
기본적으로 auto는 대입 된 값의 타입의 const와 &(참조)를 무시한다. 만약, auto 타입의 변수에 const 혹은 &타입의 변수를 대입하면, const, &를 빼고 타입을 추론한다. 즉, 참조 타입의 값을 auto에 대입한다면, 참조 타입으로 변환 되는것이 아니라, 일반적인 변수 타입으로 변환되어서 값이 참조 값이 되는것이 아니라, 대입된 값을 복사 하게 된다.
그래서 const, & 타입의 변수를 대입 할 때는 const auto 혹은 auto& 처럼 명시적으로 const, &타입을 추론하도록 해 줘야 한다.
또한 auto를 남발하게 되면, 코드 가독성이 매우 떨어지기 때문에 적절한 곳에 적절하게 사용 해야 한다.
## nullptr
전통적으로는 NULL, 즉 0을 빈 포인터에 대입하였다. 하지만 포인터형 변수에 0을 대입하는 것이 문제가 될 수 있다. 이를 해결하기 위해서 nullptr을 사용한다.
오동작을 방지하기 위해서 nullptr을 사용한다.
가독성이 좋아진다
nullptr_t -> 객체이다

## using 
typedef의 문제점을 해결하기 위한 문법
직관적이다 -> using id = int의 형태로 정의하는데 더 직관적이다. typedef보다
템플릿과 관련 -> typedef는 템플릿과 사용 불가능

## enum class
이름 공간 관리, 암묵적 변환 금지
기본 enum = unscoped enum -> 내부에서 사용한 enum의 이름이 스코프 외부에서도 사용 불가능해졌었음
enum PlayerType {Player} 이렇게 Player를 enum 내부에서 사용하면 외부에서도 Player라는 이름을 사용하지 못했음 -> enum class 는 이를 극복함 - 영역 안에서만 유효 이름 스코프 밖에서도 사용 가능

기존 enum은 암묵적으로 숫자 형태의 타입으로 변환되었지만, enum class 는 명시적으로 변환 해 주어야한다. ::를 통해서 접근 장점 혹은 단점
## 삭제된 함수 - delete
특정 함수를 허용하지 않도록 하는 키워드
예를 들면, 기본적으로 컴파일에서 생성되는 생성자들의 사용을 막고싶을때
private 영역에 선언해서 막는것은 다른 방법으로 접근 할 방법이 존재 -> delete를 사용하면 사용하지 못함 void operator=() = delete; 로 사용
## override, final
가상함수와 연관된 문법
상속 받은 클래스의 함수의 재정의를 override 라고 한다. 
overloading -> 함수 이름의 재사용
virtual 함수를 정의시에 상속받은 함수가 원본인지, 그 위의 부모가 원본인지를 판단하기 힘들다
즉, 최조의 가상 함수인지, 아니면 부모 클래스의 가상함수를 오버라이딩한 가상함수인지를 판단하기 위해서 override 키워드를 사용
void func() override -> 이렇게 사용
final 은 마지막으로 오버라이드 하고 다음 자손들의 해당 함수 오버라이드를 막는 키워드
## 전달 참조 (forwarding reference)
&& -> 오른값 참조만 있는것이 아니다
템플릿이 포함된 함수에선 &&에서 move 없이 객체만 전달 할 경우 왼값 참조로 넘어간다
auto&& 의 경우에서도 해당 타입으로 객체를 move 없이 객체만 전달 할 경우 왼값 참조로 넘어간다
위 두 경우에선 둘 다 move를 통해 넘겨주어야 오른값 참조로 넘어간다
-> 두 경우 모두 type deduce가 발생할때
함수 내부에서 전달 참조값을 구분 하는법 
오른값과 오른값 참조 타입은 다르다
오른값을 파라미터로 넣어주어도, 함수 내부에서 그 파라미터 값은 오른값 참조, 즉 진정한 의미의 오른값이 아니다.

std::forward()로 전달하면 만약 해당 타입이 왼값 참조면, 왼값으로 넘겨주고, 오른값 참조면 std::move를 자동으로 씌워서 넘겨준다

## {} 중괄호 초기화
{}를 통해 객체를 초기화
Myclass c1;
MyClass c2 { c1 }; 이렇게 초기화 가능
vector v{1, 2, 3} 과 같이 이용 가능

축소 변환 방지 -> {}를 통해 변수를 초기화 하면, 컴파일러가 축소 변환을 더 잘 감지한다
MyClass c() -> 기본생성자를 호출하는 것이 아님
MyClass c{} -> 기본 생성자 호출

이니셜라이저 리스트
initializer_list -> 우선권을 가짐
만약 (int, int) 와 같은 인자를 받는 생성자가 있을때, initializer_list를 인자로 가지는 생성자가 존재하면, initializer_list인자의 생성자가 호출 우선권을 가진다. ({} 초기화를 한 경우에만).

## 람다 (lamda)
함수 객체를 빠르게 만드는 문법
```cpp
[]() {} // 기본 형태
[] (파라미터) { 내부 로직 }
auto lam = [] (파라미터) { 내부 로직 }; -> 람다 객체 (closure) 람다의 실행 시점 객체
[내부 저장 멤버 변수] (파라미터) { 내부 로직 }; -> [] = capture 함수 객체 내부에 변수를 저장하는 개념과 유사
캡처 모드 -> [=]: 값 복사, [&]: 값 참조 -> 지양하고 아래와 같이 사용하는걸 추천 (명시적으로 어떤 변수를 사용하고 어떤 캡처모드로 사용할지를 표시)
캡처를 사용하면 외부의 변수를 람다 함수 내부에서 사용 가능
변수마다 캡처모드 지정 가능 : 값 방식 [name], 참조 방식 [&name]

```

## 스마트 포인터
포인터를 정책에 따라 관리하는 객체 (포인터 랩퍼)
shared_ptr
참조 카운트 존재 -> 몇개의 객체가 해당 포인터를 참조하고 있는가
참조 카운터가 0이 되어야 delete됨 0이 아니면 참조 카운트 --
make_shared 로 만들어 주는게 좋은 성능
-> 사이클 문제
만약 서로 각자의 포인터를 내부에서 가르키고 있는 상황 -> 서로를 참조하고 있어서 메모리가 절대 삭제가 안됨
순환 구조를 강제로 끊어줘야함

weak_ptr
순환 구조 문제 해결을 위해서
weak count가 있음
간접적으로 포인터를 참조함 -> 순환 문제에서 자유롭다 (객체의 생명주기 관여x)
하지만, 해당 포인터를 통해 작업을 하려면 expired()로 확인 후 lock()을 통해 sahred_ptr로 변환 해주어야함
unique_ptr
무조건 하나만 존재하는 포인터 -> 대입 불가능 ->move를 통해 이동만 가능