Modern C++은 일반적으로 C++11 이후 버전들의 문법들을 의미한다.
## auto
컴파일 단계에서 자체적으로 타입을 추론해서 넣어준다.
대입된 값을 바탕으로 타입을 자체적으로 넣어준다.
template과 auto 같은 타입을 자동으로 추론 해주는 것을 type deduction 이라고 한다.

복잡한 추론 규칙도 존재한다. 모든 타입을 추론 해주지는 않는다.
주의점 - 기본 auto는 const와 &를 무시한다. auto 타입의 변수에 const 혹은 &타입의 변수를 대입하면, const, &를 빼고 타입을 추론한다. 즉, 참조값을 받는것이 아니라 값이 복사가 된다. 
그래서 const, & 타입의 변수를 대입 할때는 const auto 혹은 auto& 처럼 명시적으로 const, &타입을 추론하도록 해 줘야 한다.

auto를 남발하게 되면, 코드 가독성이 매우 떨어지기 때문에 적절한 곳에 적절하게 사용해야한다.

## nullptr
전통적으로는 NULL, 즉 0을 빈 포인터에 대입하였다. 하지만 포인터형 변수에 0을 대입하는 것이 문제가 될 수 있다. 이를 해결하기 위해서 nullptr을 사용한다.
오동작을 방지하기 위해서 nullptr을 사용한다.
가독성이 좋아진다
nullptr_t -> 객체이다

## using 
typedef의 문제점을 해결하기 위한 문법
직관적이다 -> using id = int의 형태로 정의하는데 더 직관적이다. typedef보다
템플릿과 관련 -> typedef는 템플릿과 사용 불가능

## enum class
이름 공간 관리, 암묵적 변환 금지
기본 enum = unscoped enum -> 내부에서 사용한 enum의 이름이 스코프 외부에서도 사용 불가능해졌었음
enum PlayerType {Player} 이렇게 Player를 enum 내부에서 사용하면 외부에서도 Player라는 이름을 사용하지 못했음 -> enum class 는 이를 극복함 - 영역 안에서만 유효 이름 스코프 밖에서도 사용 가능

기존 enum은 암묵적으로 숫자 형태의 타입으로 변환되었지만, enum class 는 명시적으로 변환 해 주어야한다. ::를 통해서 접근 장점 혹은 단점
## {} 중괄호 초기화
{}를 통해 객체를 초기화
Myclass c1;
MyClass c2 { c1 }; 이렇게 초기화 가능
vector<int> v{1, 2, 3} 과 같이 이용 가능

축소 변환 방지 -> {}를 통해 변수를 초기화 하면, 컴파일러가 축소 변환을 더 잘 감지한다
MyClass c() -> 기본생성자를 호출하는 것이 아님
MyClass c{} -> 기본 생성자 호출

이니셜라이저 리스트
initializer_list -> 우선권을 가짐
만약 (int, int) 와 같은 인자를 받는 생성자가 있을때, initializer_list<int>를 인자로 가지는 생성자가 존재하면, initializer_list인자의 생성자가 호출 우선권을 가진다. ({} 초기화를 한 경우에만).