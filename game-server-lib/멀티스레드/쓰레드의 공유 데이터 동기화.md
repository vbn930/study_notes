## Atomic
atomic -> All or Nothing

DB -> atomic 적용

하나의 작업 묶음이 있을때, 묶음의 작업이 모두 동작하거나, 하나도 동작하지 않도록 보장하는것

atomic 은 하나의 작업이 완전히 완료되는 것을 보장한다

하지만, atomic 연산이 일반 연산보다 많이 느리다. -> 병목 현상 발생

## Lock
stl 컨테이너는 기본적으로 thread safe 하지 않다. atomic도 사용 불가능
-> mutex 를 사용해야함
<mutex>
mutex m;
m.lock();
// 이 사이 공간은 반드시 하나의 스레드에서만 동작
m.unlock();

재귀적 락 불가능 
m.lock();
m.lock(); -> 불가능

RAII 패턴 Resource Acquitistion Is Initialization
wrapper를 만들어서 범위를 벗어나면 객체가 소멸하며 해당 자원이 자동으로 소멸되도록
-> lock_guard: 생성과 동시에 락, 소멸되며 언락
-> unique_lock: 생성 시점과 락 시점이 다름, 조절 가능

### DeadLock
양쪽 스레드가 교차로 락이 걸려서 서로가 종료되기를 기다림

예방법
락 순서 정하기
adopt_lock -> 힌트 이미 락 된상태이니 나중에 풀어주기만 하면됨